===========================================
CHATTINESS ANALYSIS - Most Problematic Operations
===========================================

CRITICAL: The following operations have the highest I/O chattiness,
making them expensive and slow on object storage.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TOP 5 WORST OFFENDERS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. platinum_us_west
   ⚠️  8,460 bytes/io  |  2,415 I/O operations
   
   Pattern: Multi-attribute filter (customer_tier=platinum AND region=us-west)
   Problem: Makes 2,415 separate read operations, each only ~8KB
   Impact: ~2,415 round trips to object storage
   Cost Impact: HIGH - Each operation has fixed latency/cost overhead
   
   Why chatty: Likely reading individual spans/blocks one at a time
                instead of batch reading or better block pruning

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

2. gold_us_west  
   ⚠️  20,387 bytes/io  |  2,929 I/O operations
   
   Pattern: Multi-attribute filter (customer_tier=gold AND region=us-west)
   Problem: Makes 2,929 separate read operations, each only ~20KB
   Impact: ~2,929 round trips - WORST operation count!
   Cost Impact: CRITICAL - Most chatty query in entire benchmark
   
   Why chatty: Same pattern as #1, but even more operations

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

3. us_west_region
   ⚠️  31,363 bytes/io  |  2,348 I/O operations
   
   Pattern: Single region filter (region=us-west)
   Problem: Makes 2,348 separate read operations
   Impact: High round trip count for simple filter
   
   Why chatty: Region not efficiently indexed in block metadata

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

4. mixed_shop_and_db
   ⚠️  8,851 bytes/io  |  1,412 I/O operations
   
   Pattern: Complex OR filter (service=shop OR operation=db.*)
   Problem: Makes 1,412 operations with tiny ~9KB reads
   
   Why chatty: OR conditions likely preventing effective block pruning

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

5. count-http-5xx-errors-by-service-and-method
   ⚠️  14,288 bytes/io  |  1,176 I/O operations
   
   Pattern: Aggregation with multi-attribute filter + group by
   Problem: Makes 1,176 operations for error counting
   
   Why chatty: Aggregations with duration/time access require
               reading more columns, reducing pruning effectiveness

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PATTERN ANALYSIS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Common characteristics of chatty operations:

1. REGION-BASED FILTERS (Top 3 offenders)
   - Region attributes cause worst chattiness
   - 2,000-3,000 I/O operations per query
   - Only 8-31KB per operation
   
   Root Cause: Region likely not in block-level metadata
   → Executor must read individual spans/blocks to check region
   → No ability to prune entire blocks based on region

2. MULTI-ATTRIBUTE FILTERS
   - Combining attributes (tier + region) makes it worse
   - platinum_us_west: 2,415 ops
   - gold_us_west: 2,929 ops
   
   Root Cause: Both attributes missing from block metadata
   → Must check each condition separately
   → Amplifies the chattiness

3. AGGREGATIONS WITH MULTI-GROUP-BY
   - stats-by-service-and-status: 1,677 ops
   - count-by-service-and-kind: 1,342 ops
   - avg-duration-by-service-and-method: 1,467 ops
   
   Root Cause: Aggregations need to read duration column
   → Duration access requires reading more data per span
   → Reduces effectiveness of column pruning

4. COMPLEX OR CONDITIONS
   - mixed_shop_and_db: 1,412 ops
   
   Root Cause: OR prevents pruning on either side
   → Must read data for both conditions
   → Can't skip blocks

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

COMPARISON WITH EFFICIENT OPERATIONS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Efficient: filter_billing_service
✅ 114,984 bytes/io  |  98 I/O operations
   - 24x larger reads than platinum_us_west
   - 25x fewer operations than platinum_us_west

Efficient: database-operations  
✅ 4,700,462 bytes/io  |  2 I/O operations
   - 556x larger reads than platinum_us_west
   - 1,207x fewer operations than platinum_us_west

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

COST IMPLICATIONS FOR OBJECT STORAGE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Example with S3 pricing:
- S3 GET request: $0.0004 per 1,000 requests
- Typical latency: 50-100ms per request

platinum_us_west: 2,415 operations
- Cost: $0.00096 per query (just API calls)
- Latency: 120-240 seconds if serial (actual depends on parallelism)

database-operations: 2 operations  
- Cost: $0.000008 per query
- Latency: 0.1-0.2 seconds

Cost Ratio: platinum_us_west is 120x more expensive than database-operations!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

RECOMMENDATIONS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Priority 1: Fix Region-Based Queries (CRITICAL)
───────────────────────────────────────────────
Action: Add region to block-level metadata
Expected improvement: 2,000+ ops → ~100 ops (20-30x reduction)
Files to modify:
  - Block metadata structure to include region value ranges
  - Block pruning logic to filter on region
  - Writer to populate region metadata

Priority 2: Investigate Multi-Attribute Filters
────────────────────────────────────────────────
Action: Add customer_tier to block metadata
Expected improvement: Similar to region fix
Combined with region fix: Could reduce to ~50-100 ops total

Priority 3: Optimize Aggregation Column Access
───────────────────────────────────────────────
Action: Review duration column access patterns
Consider: Batch reading duration values instead of per-span access
Expected improvement: 1,000+ ops → ~500 ops (2x reduction)

Priority 4: Add Read-Ahead Buffering
─────────────────────────────────────
Action: Implement read-ahead buffer in TrackingReaderProvider
When: Multiple small sequential reads detected
Expected improvement: Reduce actual I/O ops by batching

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

NEXT STEPS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Profile platinum_us_west query execution
   - Trace each I/O operation
   - Identify what data is being read
   - Confirm if region is missing from block metadata

2. Prototype region metadata addition
   - Measure impact on write performance
   - Measure impact on file size
   - Run benchmark to verify I/O reduction

3. Consider blocking threshold alerts
   - Alert if bytes/io < 50KB (very chatty)
   - Alert if io_ops > 1,000 (too many round trips)
   
4. Monitor in production
   - Track actual object storage costs
   - Correlate with query patterns
   - Prioritize optimizations by actual usage

